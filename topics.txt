1) Prototype Inheritance

2) Call, apply, bind

3) Event loop

4) Callbacks and Promises (async/await)

5) map, reduce, filter

6) Arrow function
	Shorter syntax
	1 parameter no need of parenthesis
	If returning, no need of curly braces. Only when multiple statements add braces.
	No need to bind this, uses the same context
	Arrow functions do not have "arguments"

7) Rest parameters/spread
	Breaks the parameters (a,b, ...rest) into array
	
8) Classes
	get and set

	Class expressions
		The name given to a named class expression is local to the class's body. (it can be retrieved through the class's (not an instance's) name property, though).

		// unnamed
		let Rectangle = class {
		  constructor(height, width) {
		    this.height = height;
		    this.width = width;
		  }
		};
		console.log(Rectangle.name);
		// output: "Rectangle"

		// named
		let Rectangle = class Rectangle2 {
		  constructor(height, width) {
		    this.height = height;
		    this.width = width;
		  }
		};
		console.log(Rectangle.name);
		// output: "Rectangle2"

	Class declarations
		Normal way of declaring classes

	Static methods
		The static keyword defines a static method for a class. Static methods are called without instantiating their class and cannot be called through a class instance. Static methods are often used to create utility functions for an application.

	Private fields - #a

9) Recursion
	Base case, recursive case
	
10) Hoisting
	JavaScript only hoists declarations, not initializations. If a variable is declared and initialized after using it, the value will be undefined. Classes are not hoisted.
	Variables which are assigned without a var declaration are considered to be global variables
	//Example
	a = 'Cran'; //Initialize a
	b = 'berry'; //Initialize b
	console.log(a + "" + b); // 'Cranberry'
	var a, b; //Declare both a & b for hoisting

	Function declarations hoist the function definitions. Hence, functions declaration can be used before they are declared.
	Function expressions in JavaScript are not hoisted.

	https://medium.com/@pvivek4/hoisting-demystified-with-popular-interview-questions-38a93ea441ff

11) Closures/scopes
	 closures/scopes
		Global scope
		Local Scope/Function scope
		Block scope(Introduced in ES6)

12) Event Bubbling
	With bubbling, the event is first captured and handled by the innermost element and then propagated to outer elements. With capturing, the process is in reverse. We usually attach an event to a handler using the addEventListener function.
	The third argument useCapture is the key. The default value is false. So, it will be a bubbling model where the event is handled by the innermost element first and it propagates outwards till it reaches the parent element. If that argument is true, it is capturing model.
	addEventListener("click", handler, useCapture=false)
	Handling of Bubbling model ⬆️, capturing model ⬇️
	
	https://medium.com/dev-bits/a-perfect-guide-for-cracking-a-javascript-interview-a-developers-perspective-23a5c0fa4d0d

13) freeze, seal
	Object.freeze - will freeze the keys at that level, throws error in strict mode
		Object.isFrozen(obj)
	Object.seal - Cannot add new or delete property but configure them
		Object.isSealed(obj)

14) error handling patterns

15) Value vs Reference
	Primitives (copied by value)
		null
		undefined
		Number
		String
		Boolean
	Objects (copied by reference)
		Object
		Array
		Function
